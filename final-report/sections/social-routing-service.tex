\chapter{Social Routing Service}

This chapter describes in detail the Social Routing Service and it's components, specifying the role of each of them in the system
as well as their connection with each other.

The Social Routing Service (SRS) is comprised of three major components, 
a PostgreSQL based database to store user related information, a spring application to process data and an API to expose it's functionality.
This logic is represented in the figure \ref{fig:socialroutingservice}. Beyond the mentioned
components it also uses the external API Google Sign In to aid with the user authentication process.

\begin{figure}[ht]            
    \includegraphics[width=\textwidth]{images/project-structure/service-structure2.PNG}
    \caption{Social Routing Service architecture.}
    \label{fig:socialroutingservice}
\end{figure}  

The components, although separated, must communicate with each other in order for the SRS
to function properly. The API is exposed by the server using the HTTP protocol. The 
communication with external APIs made by the server is done through the HTTPS\cite{https} 
protocol.

The communication with the DBMS is made using JDBI\cite{jdbidocs}, a library built on top
of the JDBC\cite{jdbcdocs} driver. The main idea when building the communication with the DBMS
was to guarantee that a single request made to the service would use a single connection 
to the DBMS. For that reason, the connection is both created and closed in the controller
element of the system. This way it allows that the DBMS connection is used multiple times
by the same request if required.
\newpage

\section{Data Model}
The DBMS chosen was PostgreSQL\cite{postgresql}, using the hybrid functionality 
of storing valid JSON\cite{postgresqljson} directly in a table field. The decision of choosing JSON as a type to 
store data comes with the need of storing large sets of coordinates belonging to a single entity and this 
allows us to make faster and easier calculations of times and distances between routes and points rather than if a 
point was it's own database entity. 
The main concept of the project is the creation of routes in a map and their retrieval according to certain parameters.
To consider distance between a user and a route a possible search parameter, the PostGIS\cite{postgis} 
PostgreSQL extension was used as it allows both cartesian and geodesic distances calculations.

    \subsection{Conceptual Model}
    The database entity diagram is shown in figure \ref{fig:erdiagram}.

    \begin{figure}[ht]            
        \includegraphics[width=\textwidth]{images/project-structure/dbms-structure.PNG}
        \caption{Entity Relationship Diagram.}
        \label{fig:erdiagram}
    \end{figure}   

        \subsubsection*{Person}
        The entity Person represents a single user in the database. 

        \subsubsection*{Route}
        Entity that stores every information required to represent a Route. Special consideration was taken into the making
        of this entity as a Route must have large sets of coordinates, representing the path that it undergoes. 

        \subsubsection*{GoogleAuthentication}
        Google Authentication is the entity that stores the user unique identifier in the Google platform, the subject.
        In the future there will be multiple entities with different forms of authentication, hence the name GoogleAuthentication 
        of the entity. It provides scalability to further augment the authentication process, which can be done
        with a new entity FacebookAuthentication for example.

        \subsubsection*{Authentication}
        This entity is used to store authentication metadata regarding each database user. The tokens have an expiration time,
        and because of it their creation date is required as well as their expiration date.

        \subsubsection*{Category}
        The category entity defines a route in a broader sense. It is used to filter the amount of routes being 
        searched by a user. It can be one of the several: Sea, Sports, Cultural, amongst others.
        Each route must be assigned at least one category.

        \subsubsection*{PointOfInterest}
        A route might contain geographic points of interest along its path, this is the entity that represents them. 

        \subsubsection*{Image}
        The image entity represents the image that is associated with the route, namely it's cover image. It is characterized by a reference
        that allows the image's URI to be fetched.

    \subsection{Physical Model}
    The physical model can be seen in a full in the database documentation\cite{servicedbms}, the following subsections discuss 
    some of the table fields considered important.

        \subsubsection*{Person}
        The table person has only two fields, the identifier of the person, generated by the database and the person's rating.
        A user can have multiple entries on the Authentication table to enable multiple device registration, 
        but only a single Google Authentication entry as the google account is unique.

        \subsubsection*{Route}
        The route table has amongst others, a field called points. This field is of type JSON, and is used to store sets of geographic
        coordinates. The field is a JSON array of point objects and has the following structure:
            \begin{lstlisting}
    [    
        {
            "latitude" : double,
            "longitude": double
        },
        ...
    ]
            \end{lstlisting}
        This structure allows the mapping of multiple points to a single route.
        Two other very important fields are the booleans ordered and circular. The field ordered is used to store if a route should start only at it's first geographic
        point or if the order of which a user can undergo is not defined. The circular parameter is used to verify if a route ends where it starts,
        because if that is the case, then the route can be started by the user in any of the route's geographic points-

        \subsubsection*{GoogleAuthentication}
        The google authentication table is used to store google account information, more specifically the subject which is primary
        key. Only one google account per user is allowed.

        \subsubsection*{Authentication}
        The authentication table stores the user credentials generated by the Social Routing Service. It contains the access token, the refresh
        token, the date of creation and the expiration date of the access token as well as the person identifier. The primary key of the table is the refresh token, as a single
        person can have multiple entries on this table, to allow multiple devices to be logged in while maintaining the same account.

        \subsubsection*{Category}
        The category entity characterizes a route in a broader sense. It is used to filter the amount of routes being 
        searched by a user. It can be one of the several: Sea, Sports, Cultural, amongst others. The categories available
        are manually inserted to the database. Each route must be assigned at least one category.

        \subsubsection*{PointOfInterest}
        A point of interest is a pair of geographic coordinates (latitude and longitude) and it's reference to the google platform.

        \subsubsection*{Image}
        The table image contains a single field which is it's primary key, a reference. This is the image's unique identifier in the google
        platform.

    \subsection{Route Search}
    The SRS allows that a service client searches routes that are inside a predetermined area. This feature is useful to determine
    if a route is close to a user location or not. This functionality is exposed in an SQL query\cite{sqlqueries} and an SQL function\cite{sqlfunctions}.
    
    The route search algorithm is made in two different phases, the first uses a set of parameters such as the categories of the routes being searched,
    the duration desired and the geographic location being searched. These parameters function as initial filters to reduce the 
    number of inputs being worked over.

    After this initial list of routes is reduced to relevant routes, the algorithm must then check which of these routes are in the user desired area.
    The user desired area is by default a 1km circumference around the user's geographic coordinates, but a few other aspects have to be considered
    when choosing the perfect route. When a route is initially created, it has characterization related to its ordering, this allows for a better route suggestion
    algorithm, as a circular route can be started in any of its points, where an ordered route can only be started in it's first point. A user far from the starting
    point (over 1km distance) would not want it to be suggested to him, as he would have to walk too much to the starting point only to come back to undergo the route.
    An example of this scenario can be seen in \ref{fig:startingpoint}
    
    \begin{figure}[H]            
        \includegraphics[width=\textwidth]{images/project-structure/starting-point.PNG}
        \caption{Starting point is outside the user area example.}
        \label{fig:startingpoint}
    \end{figure}   

    For a route that starts where it also ends this poses no problem, as any point can be suggested as a starting point to the user as seen in \ref{fig:circularexample}
    The user can go straight to the closest point and start the route, so the fact that the route is circular immediately makes it relevant to the user in this
    specific case.

    \begin{figure}[H]            
        \includegraphics[width=\textwidth]{images/project-structure/circular-example.PNG}
        \caption{Relevant circular route example.}
        \label{fig:circularexample} 
    \end{figure}   

    The third case is when a rout is not ordered and can be started either by the first or last geographic route point. An example can be seen in figure \ref{fig:unorderedexample}.
    \begin{figure}[H]            
        \includegraphics[width=\textwidth]{images/project-structure/unordered-example.PNG}
        \caption{Relevant unordered route example.}
        \label{fig:unorderedexample} 
    \end{figure}   
    Because the route does not require the user to start from the first geographic point, then the choice between the first and last is available, 
    and in this case, as seen in figure \ref{fig:unorderedexample} the path B, to the last point of the route is much shorter than path A. If the route was ordered
    it would not be relevant to this user, but the possibility of starting from the end makes it relevant.

    After initial filters are applied the algorithm's second phase begins, being that it will vary according to the previously described fields
    circular and ordered. 
    If a route is circular, the geographic location of the user (latitude and longitude) will be compared with every point each of the already filtered routes,
    to check if they belong to the user area. If they belong to the area they are considered relevant, if not they are discarded.

    If a route is ordered the starting point of the route is the only one being compared to the user's location, if not, both the final and starting point are
    compared. Like the circular, the ones that belong to the area remain, the rest are discarded.

    From a technical point of view, to be able to calculate if a route belongs to a user given area, the user coordinates are transformed into a Geographic Object\cite{geographicobject},
    then, each of the already filtered and retrieved routes is checked for distance to that geographic object. To be noted that the construction of a geographic
    object is necessary because the calculations being made are not made on the cartesian plane but on the spatial one. They must be made considering a spherical 
    object to provide accurate results (in case a long distance between route points exists). Each route contains every geographic point in its field points,
    which is of type JSON. Of of each of the routes, its points must be extracted and converted into the same Geographic Object type. From here, using the built in function
    of the PostGIS extension STDistance \cite{stdistance}, the distance between points is retrieved, if it's within the selected radius, it's selected, otherwise it is discarded.
    
    \newpage
\section{Social Routing API} \label{apisection}   
    \subsection{Schema} 
        The Social Routing API uses the HTTP protocol as a medium to communicate and all the data sent or received must be in the JSON format.
        The base endpoint of the API is : http://api.sr.\par
        Data obtained from the API is either a single resource or a collection of resources. For example, a request
        made to retrieve a route will have as a response a single resource which will contain the representation of that
        route. If a request is made to obtain routes by location then the response will be a collection of resources containing
        the several route representations. This single and collection terms when associated with a
        resource were decisive in the choice of how much data would be returned in either of them. A request for a collection
        doesn't require detailed information about each element of the collection, it needs to provide general information and
        a form for the API user to retrieve detailed information about a specific collection element.
        With this idea in mind the resource representations were divided into two types, a detailed representation for when a user
        requests a single resource and summary representation for each element inside a requested collection, containing only the 
        information about that element that is necessary.
        Examples of both a detailed and summary representation can be found in the Schema Documentation \cite{schemadocs}.    
    
        \newpage
    
    \subsection{Authentication} \label{authsection}
    The authentication has two different endpoints, one to obtain credentials to access the API and the other to refresh 
    the already obtained credentials. To make an authenticated request to the API the user must make every request with 
    the already obtained access token in the Authorization header of the request.
    
    \subsubsection*{Obtaining credentials} \label{apiobtcred}
    To obtain API credentials a POST \cite{httppostdocs} request must be made to the endpoint: http://api.sr/auhtentication/google, 
    with the id token string in the body of the request:
    \begin{lstlisting}
    {
      idTokenString : "id token string"
    }
     \end{lstlisting}
    The request to this endpoint receives a response containing all the necessary data to make authenticated requests to the API.
    An example response:
    \begin{lstlisting}
        {
            "accessToken" : "access token 1",
            "refreshToken": "refresh token 1"
        }
    \end{lstlisting}

    \subsubsection*{Refreshing the credentials}
    To refresh credentials a POST request must be made to the endpoint: http://api.sr/auhtentication/refresh containing in it's
    body the refresh token. If the refresh token is valid a response with a new access token and refresh token is generated.

    \newpage
    \subsection{Supported HTTP Methods}
        Due to the nature of the HTTP protocol, the API supports four different HTTP request methods \cite{apihttpverbsdocs}: GET, POST, PUT and DELETE.
        
        \subsubsection*{GET}
        This method is used to retrieve resources from the API. The request: 
        \begin{verbatim}
            GET http://api.sr/persons/1 
        \end{verbatim}
        \vspace{-\baselineskip}
        retrieves a resource representing a person resource with the identifier 1. 
        The response to this request would be:
        \begin{lstlisting}
        {
          "identifier": 1,
          "rating": 4,
          "routesUrl": "http://api.sr/persons/1/routes"
        }
        \end{lstlisting}

        \subsubsection*{POST}
        The POST HTTP method is used to create resources. It requires that the Content-Type\cite{contenttype}HTTP header is 
        defined with the value application/json\cite{applicationjson}. An example of a post request can be found in the 
        API POST\cite{apipostdocs} documentation. A response to a POST request has an empty body and returns the 
        location of the created resource in it's Location header. If successful the status code of a POST request response is 201.  
            
        \subsubsection*{PUT}
        The PUT method is used to replace or update a resource or a collection of resources. Like the post request it requires 
        that the request contains the HTTP header Content-Type defined with application/json.
        The following request replaces the currently existing resource route with identifier 1 with the one sent in 
        the body of the request. A successful response has the 200 OK status and an empty body. An example of a put 
        request can be found in the API PUT\cite{apiputdocs} documentation.

        \subsubsection*{DELETE}
        DELETE, as the name implies is utilized to delete a resource. The request: 
        \begin{verbatim}
            DELETE http://api.sr/routes/1
        \end{verbatim}
        \vspace{-\baselineskip} 
        deletes the route with 1 as identifier. A successful response will have the 200 OK status and an empty body.
    
    \subsection{Pagination}
    Requests that return a collection of resources will be paginated to a default value of 10 resources within the collection. 
    A specific page can be requested with the query parameter page. If no page is specified then the first page is assumed by default.
    The request:  
    \begin{verbatim}
        GET http://api.sr/persons/1/routes?page=1
    \end{verbatim}
    \vspace{-\baselineskip}
    The response would contain a collection of the first ten routes that a person with identifier 1 created.
    To obtain the next ten one would simply change de value of page to 2. If no further routes are available then a response with
    the status not found and error code 404 is returned.

    \subsection{Errors}
    The error responses follow the RFC standard of type problem+json\cite{jsonproblemonlinedocs}. An error response example:
    
    \begin{lstlisting}
    {
      "type": "Social-Routing-API#unsupported-media-type",
      "title": "The requested type is not supported.",
      "status": "415",
      "detail": "The xml format is not supported."
    }
    \end{lstlisting}

    The type field contains a link to the API documentation which further describes the type of error generated.
    The title describes succinctly what the error is about.
    The status is the corresponding HTTP status for the specific error.
    Detail is a more detailed message about the error encountered.

    \subsection{Hypermedia}
    
    \begin{figure}[H]            
        \includegraphics[width=\textwidth]{images/project-structure/hypermedia-relations.PNG}
        \caption{Hypermedia.}
        \label{fig:hypermedia-relations}
    \end{figure}   

    Some resources have links to other resources. Either to a parent resource or to a detailed representation of a 
    resource within a collection. For example, a user resource haves a link to their created routes, which 
    holds a collection of routes. That same collection haves a link to the profile of the person who created 
    the routes. A detailed relationship diagram containing the most relevant relations can be found in figure \ref{fig:hypermedia-relations} 
    
    \newpage

\section{Server} 
The server uses Kotlin as a programming language and the Spring framework\cite{springwebsite}. 
It's role within the system is data receival, data processing, 
and to respond accordingly. It is divided in three major layers, each with it's role in the Social Routing Service's system. 
They are the Controllers, the Services and the Repository.

The Controllers are responsible for handling the reception of an HTTP request to the service and are mapped to
it's endpoints. Upon receiving a request they will use the available services to perform desired operations either
over a set of received data or to generate the requested data.

The Services are responsible for processing data and communicating the the Repository layer.

The Repository layer is the only layer with direct access to the database and as such is responsible for communicating
with it. The communication is made through the use of JDBI\cite{jdbidocs}, a library built on top of the driver JDBC\cite{jdbcdocs}. This allows
less verbose code while maintaining control over SQL queries. 

Besides these three major layers the server contains other important components, the Interceptor\cite{springinterceptor} and the Exception Handler\cite{springexception}.
There are three different implementations of the Interceptor component.

The Authentication Interceptor is responsible for user authentication before the request reaches a controller. The goal of this
implementation is to avoid server overhead, resolving the authentication before the request is processed allows for a fast response
if the user is incorrectly authenticated instead of continuing with the unnecessary processing of data.

The Logging Interceptor is used both before and after the request is processed to provide information 
regarding each request for debugging purposes.

The Media Type Interceptor is used, like the Authentication Interceptor, to avoid overhead, since if a post request is made
with wrong Content-Type headers or no headers at all then the service does not support that request and can respond with an 
error immediately.

The Exception Handler is the component responsible for the handling of exceptions of the system. In the Spring framework there 
are several ways to handle exceptions, but the choice to make is to either handle the exceptions locally or globally. The 
handler implementation groups all the exceptions thrown by the system in a single class and produces their respective error 
messages. It allows for an easier work flow when treating exceptions. The global handling was chosen because most of the 
exceptions happen in more than one endpoint and would produce a lot of repeated code if handled locally.      
\newpage
As an example, the flow of a correct HTTP POST request to the routes resource that arrives on the server is the following:
    \begin{itemize}
        \item The request is intercepted by the Logging Interceptor and logs the request information.
        \item It is then intercepted by the Media Type Interceptor, that checks if the request data format 
        received is supported by the service.
        \item The Authentication Interceptor checks the user credentials to see if the user can indeed access the service.
        \item The endpoint is reached in it's mapped Controller, which receives the Route information and that it 
        maps to the correct object. In this case the Route Controller which will then call a service responsible 
        for processing the request data.
        \item The service, in this case Route Service, will process the data and map it  to the correct data type 
        and make a request to the repository to store the received data.
        \item The repository communicates with the database, to which it sends the data in a database accepted format.
        \item The database stores the data and returns the identifier of the newly created Route.
        \item The repository receives the identifier and passes it through to the Route Service.
        \item The Service passes the received information to the Route Controller.
        \item The Route Controller builds the newly created route resource URI with the received Route identifier 
        and maps it to the header Location of the response and returns.
    \end{itemize}
    \newpage

    \subsection{Authentication}

    The nature of the project requires that user information such as user made routes is stored and
    because of this user authentication is required.  

    The service handles two main types of authentication requests, one to generate the user credentials and the other to refresh or update
    already existing credentials. A detailed view of the Social Routing Service and the components that interfere with the authentication process can be seen 
    in \ref{fig:serviceauth}.
    
    \begin{figure}[ht]            
        \includegraphics[width=\textwidth]{images/project-structure/service-auth.PNG} 
        \caption{Authentication components diagram.}
        \label{fig:serviceauth}
    \end{figure}   

    \subsubsection*{Generation of Credentials}
    When a request is received, as mentioned in \ref{apiobtcred}, it must contain the id token string of the user's google account. 
    When the controller receives it the first step is validation of the token, for that an external API is used (Google Sign In API), that has it's usage wrapped 
    in the GoogleAuthenticationService\cite{googleauthservicecode}. This service is responsible for all actions pertaining Google Authentication's specific processing.
    Once the token is validated and the sub extracted from it, the sub is checked against the database to see if any user with it is already registered, if not,
    the user is created. Along with user creation, the controller requests both the access token and refresh token from the AuthenticationService's\cite{authservicecode}
    available functionalities. The tokens are generated using Java's Secure Random class\cite{securerandom} and hashed before being stored in the database. 
    The access token and refresh token are sent in their original form as a response to the request maker, so that further API requests have valid credentials.

    \subsubsection*{Credential Refreshment}
    A valid API user will have both an access token and a refresh token to make authenticated requests to the API, but the tokens themselves have a duration of a day.
    For this reason if an API client makes a request to it and a day has passed since the token has been obtained then the client needs to update his credentials.
    To do that a request must be made using the refresh token, obtaining newly generated credentials from the service.

    Apart from these two distinctions, the service client still also needs to worry about making authenticated requests, which can be made by adding a valid
    access token to the Authorization header of the response as detailed in section \ref{authsection}.
    Behind every request made to the service, the Authorization header is checked, to validate the user making the request. This is made in the AuthenticationInterceptor 
    class \cite{authinterceptor}. 

   
